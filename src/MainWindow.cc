  /// \file MainWindow.cc
/*
 *
 * MainWindow.cc source template automatically generated by a class generator
 * Creation date : mer. mars 22 2017
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "MainWindow.h"

#include <QSplitter>
#include <QDateTime>
#include <QStatusBar>
#include <QHeaderView>
#include <QLayout>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QScrollBar>
#include <QLabel>

MainWindow::MainWindow() :
  QMainWindow(nullptr),
  m_maxSize(10000),
  m_loggerEntryId(0),
  m_logLevel(dqm4hep::core::Logger::TRACE)
{
  m_loggerPtr = dqm4hep::core::Logger::createLogger("logger-gui", {dqm4hep::core::Logger::coloredConsole()});
  this->build();
}

//-------------------------------------------------------------------------------------------------

MainWindow::~MainWindow()
{
  /* nop */
}

//-------------------------------------------------------------------------------------------------

void MainWindow::setMaxSize(size_t maxSize)
{
  m_maxSize = maxSize;
}

//-------------------------------------------------------------------------------------------------

void MainWindow::build()
{
  QSplitter *pCentralWidget = new QSplitter(Qt::Horizontal);
  this->setCentralWidget(pCentralWidget);

  // left view
  m_pLoggersTree = new QTreeWidget(this);
  pCentralWidget->addWidget(m_pLoggersTree);
  m_pLoggersTree->setHeaderLabel("Loggers");

  // right view
  QWidget *pRightWidget = new QWidget(this);
  pCentralWidget->addWidget(pRightWidget);
  pRightWidget->setLayout(new QVBoxLayout());


  // tool box
  QWidget *pToolBoxWidget = new QWidget(this);
  pToolBoxWidget->setLayout(new QHBoxLayout());
  pRightWidget->layout()->addWidget(pToolBoxWidget);

  m_pShowLastMessage = new QCheckBox("Show last entry");
  m_pShowLastMessage->setChecked(true);
  pToolBoxWidget->layout()->addWidget(m_pShowLastMessage);

  QLabel *pLoggerLabel = new QLabel("Logger :");
  pToolBoxWidget->layout()->addWidget(pLoggerLabel);
  m_pLoggerEdit = new QLineEdit();
  pToolBoxWidget->layout()->addWidget(m_pLoggerEdit);
  connect(m_pLoggerEdit, SIGNAL(editingFinished()), this, SLOT(updateLogTable()));

  QLabel *pMessageLabel = new QLabel("Message :");
  pToolBoxWidget->layout()->addWidget(pMessageLabel);
  m_pMessageEdit = new QLineEdit();
  pToolBoxWidget->layout()->addWidget(m_pMessageEdit);
  connect(m_pMessageEdit, SIGNAL(editingFinished()), this, SLOT(updateLogTable()));

  QLabel *pHostLabel = new QLabel("Host :");
  pToolBoxWidget->layout()->addWidget(pHostLabel);
  m_pHostNameEdit = new QLineEdit();
  pToolBoxWidget->layout()->addWidget(m_pHostNameEdit);
  connect(m_pHostNameEdit, SIGNAL(editingFinished()), this, SLOT(updateLogTable()));

  QLabel *pLevelLabel = new QLabel("Level :");
  pToolBoxWidget->layout()->addWidget(pLevelLabel);

  m_pLogLevelBox = new QComboBox(this);
  m_pLogLevelBox->addItem("trace", static_cast<int>(dqm4hep::core::Logger::TRACE));
  m_pLogLevelBox->addItem("debug", static_cast<int>(dqm4hep::core::Logger::DEBUG));
  m_pLogLevelBox->addItem("info", static_cast<int>(dqm4hep::core::Logger::INFO));
  m_pLogLevelBox->addItem("warning", static_cast<int>(dqm4hep::core::Logger::WARN));
  m_pLogLevelBox->addItem("error", static_cast<int>(dqm4hep::core::Logger::ERROR));
  m_pLogLevelBox->addItem("critical", static_cast<int>(dqm4hep::core::Logger::CRITICAL));
  pToolBoxWidget->layout()->addWidget(m_pLogLevelBox);
  connect(m_pLogLevelBox, SIGNAL(currentIndexChanged(int)), this, SLOT(logLevelChanged(int)));

  // log table
  m_pLogEntriesTable = new QTableWidget(this);
  pRightWidget->layout()->addWidget(m_pLogEntriesTable);

  QStringList headerLabels;
  headerLabels << "ID" << "Time stamp" << "Level" << "Logger" << "Message" << "Host name" << "PID";
  m_pLogEntriesTable->setColumnCount(headerLabels.size());
  m_pLogEntriesTable->setHorizontalHeaderLabels(headerLabels);
  m_pLogEntriesTable->horizontalHeader()->setStretchLastSection(true);
  m_pLogEntriesTable->horizontalHeader()->setResizeMode(QHeaderView::ResizeToContents);
  m_pLogEntriesTable->verticalHeader()->setVisible(false);

  m_pClearButton = new QPushButton("Clear");
  pRightWidget->layout()->addWidget(m_pClearButton);
  pRightWidget->layout()->setAlignment(m_pClearButton, Qt::AlignRight);
  connect(m_pClearButton, SIGNAL(pressed()), this, SLOT(clear()));

  m_client.subscribe("/dqm4hep/logcollector/log", this, &MainWindow::receiveLoggerEntry);
  connect(this, SIGNAL(loggerEntryReceived(const Json::Value &)), this, SLOT(addLoggerEntry(const Json::Value &)));

  this->resize(1200, 600);
  QList<int> sizes;
  sizes << 200 << 1000;
  pCentralWidget->setSizes(sizes);
}

//-------------------------------------------------------------------------------------------------

void MainWindow::receiveLoggerEntry(const std::string &entryStr)
{
  Json::Reader reader;
  Json::Value logEntry;

  if(reader.parse(entryStr, logEntry))
  {
    dqm_logger_error(m_loggerPtr, "Invalid received log entry. Expected json string !");
    return;
  }

  emit loggerEntryReceived(logEntry);
}

//-------------------------------------------------------------------------------------------------

void MainWindow::addLoggerEntry(const Json::Value &value)
{
  int lastRow = m_pLogEntriesTable->rowCount();

  // shrink table if max size reached
  if(lastRow >= m_maxSize)
    m_pLogEntriesTable->removeRow(0);

  lastRow = m_pLogEntriesTable->rowCount();

  bool sortingEnabled(m_pLogEntriesTable->isSortingEnabled());

  if(sortingEnabled)
    m_pLogEntriesTable->setSortingEnabled(false);

  dqm4hep::core::Logger::Level logLevel = static_cast<dqm4hep::core::Logger::Level>(value.get("level", "").asInt());
  time_t timeStamp(static_cast<time_t>(value.get("time", "").asInt64()));
  QDateTime dateTime;
  dateTime.setTime_t(timeStamp);

  QString loggerEntryIdStr(QString::number(m_loggerEntryId));
  QString loggerName(QString::fromStdString(value.get("name", "").asString()));
  QString logLevelStr(QString::fromStdString(dqm4hep::core::Logger::logLevelToString(logLevel)));
  QString message(QString::fromStdString(value.get("message", "").asString()));
  QString timeStampStr(dateTime.toString("ddd MMMM hh:mm:ss AP"));
  QString hostName(QString::fromStdString(value.get("host", "").asString()));
  QString pidStr(QString::number(value.get("pid", "").asInt()));

  m_pLogEntriesTable->insertRow(lastRow);
  m_pLogEntriesTable->setItem(lastRow, 0, this->createTableItem(loggerEntryIdStr, this->color(logLevel)));
  m_pLogEntriesTable->setItem(lastRow, 1, this->createTableItem(timeStampStr, this->color(logLevel)));
  m_pLogEntriesTable->setItem(lastRow, 2, this->createTableItem(logLevelStr, this->color(logLevel)));
  m_pLogEntriesTable->setItem(lastRow, 3, this->createTableItem(loggerName, this->color(logLevel)));
  m_pLogEntriesTable->setItem(lastRow, 4, this->createTableItem(message, this->color(logLevel)));
  m_pLogEntriesTable->setItem(lastRow, 5, this->createTableItem(hostName, this->color(logLevel)));
  m_pLogEntriesTable->setItem(lastRow, 6, this->createTableItem(pidStr, this->color(logLevel)));

  m_pLogEntriesTable->item(lastRow, 2)->setData(Qt::UserRole, static_cast<int>(logLevel));

  if(this->hideMessage(loggerName, logLevel, message, hostName))
    m_pLogEntriesTable->setRowHidden(lastRow, true);

  if(sortingEnabled)
    m_pLogEntriesTable->setSortingEnabled(true);

  if(m_loggerEntryId == std::numeric_limits<uint64_t>::max())
    m_loggerEntryId = 0;
  else
    ++m_loggerEntryId;

  if(m_pShowLastMessage->isChecked())
    m_pLogEntriesTable->verticalScrollBar()->setSliderPosition(m_pLogEntriesTable->verticalScrollBar()->maximum());

  // update tree view
  QTreeWidgetItem *pLoggerItem(0), *pHostItem(0);
  QList<QTreeWidgetItem *> items = m_pLoggersTree->findItems(loggerName, Qt::MatchExactly);

  if(items.empty())
  {
    pLoggerItem = new QTreeWidgetItem(m_pLoggersTree, QStringList(loggerName));
    m_pLoggersTree->addTopLevelItem(pLoggerItem);
  }
  else
  {
    pLoggerItem = items.at(0);
  }

  for(int i=0 ; i<pLoggerItem->childCount() ; i++)
  {
    if(pLoggerItem->child(i)->text(0) == hostName)
    {
      pHostItem = pLoggerItem->child(i);
      break;
    }
  }

  if(!pHostItem)
    pLoggerItem->addChild(new QTreeWidgetItem(QStringList(hostName)));

  statusBar()->showMessage("Last log entry at '" + timeStampStr + "'");
}

//-------------------------------------------------------------------------------------------------

QColor MainWindow::color(LogLevel level)
{
  QColor color;

  switch(level)
  {
    case dqm4hep::core::Logger::TRACE:
    {
      color.setNamedColor("#CED9FF");
      break;
    }
    case dqm4hep::core::Logger::DEBUG:
    {
      color.setNamedColor("#92ACFF");
      break;
    }
    case dqm4hep::core::Logger::WARN:
    {
      color.setNamedColor("#FFF864");
      break;
    }
    case dqm4hep::core::Logger::ERROR:
    {
      color.setNamedColor("#FF4040");
      break;
    }
    case dqm4hep::core::Logger::CRITICAL:
    {
      color.setNamedColor("#FF4040");
      break;
    }
    case dqm4hep::core::Logger::OFF:
    case dqm4hep::core::Logger::INFO:
    default:
    {
      color.setNamedColor("#FFFFFF");
      break;
    }
  }

  return color;
}

//-------------------------------------------------------------------------------------------------

QTableWidgetItem *MainWindow::createTableItem(const QString &label, const QColor &background)
{
  QTableWidgetItem *pTableItem = new QTableWidgetItem(label);
  pTableItem->setBackground(background);
  pTableItem->setForeground(Qt::black);
  pTableItem->setFlags(Qt::NoItemFlags);

  return pTableItem;
}

//-------------------------------------------------------------------------------------------------

bool MainWindow::hideMessage(const QString &logger, LogLevel level, const QString &message, const QString &hostName)
{
  LogLevel displayedLevel(static_cast<LogLevel>(m_pLogLevelBox->itemData(m_pLogLevelBox->currentIndex()).value<int>()));

  if(level < displayedLevel)
    return true;

  QString loggerFilter(m_pLoggerEdit->text());

  if(!logger.contains(loggerFilter, Qt::CaseInsensitive))
    return true;

  QString messageFilter(m_pMessageEdit->text());

  if(!message.contains(messageFilter, Qt::CaseInsensitive))
    return true;

  QString hostFilter(m_pHostNameEdit->text());

  if(!hostName.contains(hostFilter, Qt::CaseInsensitive))
    return true;

  return false;
}

//-------------------------------------------------------------------------------------------------

void MainWindow::logLevelChanged(int index)
{
  this->updateLogTable();
}

//-------------------------------------------------------------------------------------------------

void MainWindow::updateLogTable()
{
  LogLevel displayedLevel(static_cast<LogLevel>(m_pLogLevelBox->itemData(m_pLogLevelBox->currentIndex()).value<int>()));

  for(int i=0 ; i<m_pLogEntriesTable->rowCount() ; i++)
  {
    LogLevel entryLevel(static_cast<LogLevel>(m_pLogEntriesTable->item(i, 2)->data(Qt::UserRole).value<int>()));

    bool hideMessage(this->hideMessage(
      m_pLogEntriesTable->item(i, 3)->text(),
      entryLevel,
      m_pLogEntriesTable->item(i, 4)->text(),
      m_pLogEntriesTable->item(i, 5)->text()));

    m_pLogEntriesTable->setRowHidden(i, hideMessage);
  }
}

//-------------------------------------------------------------------------------------------------

void MainWindow::clear()
{
  m_pLogEntriesTable->clearContents();
  m_pLogEntriesTable->setRowCount(0);
  m_pLoggersTree->clear();
  m_loggerEntryId = 0;
}



//
